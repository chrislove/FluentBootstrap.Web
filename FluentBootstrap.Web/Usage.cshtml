@using FluentBootstrap

@{
    Page.Title = "Usage";
    Layout = "_Layout.cshtml";
}

<p>Most of the functionality in FluentBootstrap is provided via extension methods on a special <code>BootstrapHelper</code> class obtained through the standard <code>HtmlHelper</code>. This helps segregate the many extension methods and keeps them from polluting the standard <code>HtmlHelper</code> extensions list. In general, you get access to the <code>BootstrapHelper</code> class as <code>@@Html.Bootstrap()</code>.</p>
<p>FluentBootstrap is designed as a fluent interface, which means that most components are configured via a chain of method calls. In general, you create a component after getting the <code>BootstrapHelper</code> and then configure it until it's output. A typical FluentBootstrap component might look like this:</p>
@Html.Code(@"@Html.Bootstrap().Dropdown(""My Dropdown"").SetSize(ButtonSize.Xs).SetState(ButtonState.Warning)")
<p>Components are also often provided with overloaded initial methods so that you don't need to use the fluent interface for the most common scenarios. For example:</p>
@Html.Code(@"@Html.Bootstrap().Alert(AlertState.Warning, ""Warning"", ""Yikes, this is a warning."")")

@**********************************@

@Html.Bootstrap(this).PageHeader("Output")

<p>FluentBootstrap has a number of different ways to get the rendered HTML of your component (for example, to write it to the page output stream).</p>

@Html.Bootstrap(this).Heading3("IHtmlString and ToHtmlString()")

<p>When you use the @@ symbol in Razor, you're really passing an object to the Razor rendering engine and telling it to write that object to the output stream. One of the main ways it does this is to look for the object to implement <code>IHtmlString</code>. All of the FluentBootstrap component implement this interface and will render their HTML to the output stream when used with the @@ symbol. Keep in mind that this rendering will occur <em>at the end</em> of the fluent method chain once all methods have been evaluated.</p>

@Html.Bootstrap(this).Heading3("IDisposable And Begin/End")

<p>FluentBootstrap components can also be used as <code>IDisposable</code> objects (primarily for use in <code>using</code> statements for automatic tag closing). To do this, you need to call <code>.Begin()</code> on the component (for a discussion about why you have to make an extra call to get the IDisposable, <a href="http://www.somedave.com/posts/method-chaining-fluent-interfaces-and-the-finishing-problem">see here</a>). As soon as you call <code>.Begin()</code>, the component is immediately rendered to the output stream and a special wrapper is returned that provides extensions specific to the component being rendered.</p>
@Html.Code(@"using (var list = Html.Bootstrap().List(ListType.Ordered).Begin())
{
    @list.ListItem(""One"")
    @list.ListItem(""Two"")
}")
<p>If you forget to call <code>.Begin()</code>, you will get a compile-time error if you have pre-compilation turned on, or a run-time error if not, informing you that the component could not be converted to an <code>IDisposable</code>. This is intentional and is intended to ensure you remember to call <code>.Begin()</code> when using a component in a <code>using</code> statement.</p>
<p>As an alternative to a <code>using</code> statement, you can also manually begin and end the component.</p>
@Html.Code(@"var list = Html.Bootstrap().List(ListType.Ordered).Begin();
@list.ListItem(""One"")
@list.ListItem(""Two"")
list.End();
")
<p>Notice how <code>list.End();</code> is not preceded by a @@. That's because both <code>.Begin()</code> and <code>.End()</code> write directly to the output stream and do not return an <code>IHtmlString</code> interface. If you forget and add the @@, you will get a compile-time error if you have pre-compilation turned on, or a run-time error if not.</p>

@Html.Bootstrap(this).Heading3("Outputting to a String")

<p>It's also possible to defer rendering and/or output the component to a string.</p>
@Html.Code(@"var dropdown = Html.Bootstrap().Dropdown(""My Dropdown"");
dropdown.SetSize(ButtonSize.Xs);
dropdown.SetState(ButtonState.Warning);
var renderedDropdown = dropdown.ToString();")
<p>This approach can be helpful if you're trying to output content for JavaScript or otherwise need to post-process the rendered component.</p>

@**********************************@

@Html.Bootstrap(this).PageHeader("Children")

<p>Many Bootstrap components have logical children. For example, a grid row has grid columns and a list has list items. FluentBootstrap has a number of facilities to help with children. For starters, when you use <code>.Begin()</code> to use a component inside a <code>using</code> statement, an object will be returned that restricts the list of additional FluentBootstrap components to those children that are most common for the containing component (keep in mind that you're not limited to what the returned class provides - you can always use the default <code>BootstrapHelper</code> inside another component).</p>
<p>Another scenario you might encounter is when you need to build an entire component hierarchy without outputting to the output stream. This can be accomplished using the <code>.AddChild()</code> extension method. For example:</p>
@Html.Code(@"string list = Html.Bootstrap().List(ListType.Ordered)
    .AddChild(x => x.ListItem(""One""))
    .AddChild(x => x.ListItem(""Two""))
    .ToString();")
<p>Each call to <code>.AddChild()</code> returns context back to the original component when done. If on the other hand you just want to add a single child you can use the <code>.WithChild()</code> extension method.</p>
@Html.Code(@"@Html.Bootstrap().List(ListType.Ordered).WithChild().ListItem(""Single List Item"")")

@**********************************@

@Html.Bootstrap(this).PageHeader("Mixing Code And Markup")

<p>There is nothing wrong with mixing FluentBootstrap code and regular HTML markup or Bootstrap CSS. The two are designed to work well together, and it is recommended that you use whatever syntax provides the most understanding and benefit in your view code. For example, while FluentBootstrap has a <code>.Paragraph()</code> extension, you'll probably want to use the standard <code>&lt;p&gt;</code> HTML tag instead because it's much shorter.</p>
<p>The one thing to keep in mind when mixing code and markup is that you may need to change context from code back to markup if you're inside a FluentBootstrap code block and you don't need to open a new HTML tag. Thankfully, Razor provides both the <code>&lt;text&gt;</code> tag and the <code>@@:</code> syntax to help achieve this. @Html.Bootstrap(this).Link("Here is a great blog article", "http://weblogs.asp.net/scottgu/asp-net-mvc-3-razor-s-and-lt-text-gt-syntax") on the use of these two syntactical features.</p>

@Html.Code(@"@using(var row = Html.Bootstrap().GridRow().Begin())
{
    using(row.GridColumn(12).Begin())
    {
        // We are in a code context here and need to escape back to markup
        <text>My content.</text>
    }
}")

@**********************************@

@Html.Bootstrap(this).PageHeader("Examples")
<p>There is a lot more to FluentBootstrap than what's described here. You can take a look at the sections of this site that roughly track those of the Bootstrap documentation (such as @Html.Bootstrap(this).Link("CSS", "/CSS")). You can also view additional examples by looking at the <a href="https://github.com/somedave/FluentBootstrap/tree/master/FluentBootstrap.Tests.Web/Views/Tests">tests in the FluentBootstrap repository</a>.</p>